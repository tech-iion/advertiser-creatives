<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Endless Runner - Three.js Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #TutContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #scoreText {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }
        
        #infoText {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #gameOverScreen.show {
            display: flex;
        }
        
        .game-over-content {
            text-align: center;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .game-over-title {
            font-size: 72px;
            color: #ff6b6b;
            margin-bottom: 20px;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.7);
        }
        
        .final-score {
            font-size: 36px;
            color: #fff;
            margin-bottom: 40px;
        }
        
        #restartButton {
            padding: 20px 50px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        #restartButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
        }
        
        #restartButton:active {
            transform: translateY(-1px);
        }
        
        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 20px;
            z-index: 10;
        }
        
        @media (max-width: 768px), (hover: none) {
            #mobileControls {
                display: flex;
            }
            
            #infoText {
                font-size: 12px;
                padding: 10px 15px;
                top: 10px;
                right: 10px;
            }
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            color: #fff;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            user-select: none;
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }
        
        .control-row {
            display: flex;
            gap: 20px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">Loading...</div>
    <div id="TutContainer"></div>
    <div id="scoreText">0</div>
    <div id="infoText">
        <strong>Desktop:</strong> Arrow Keys<br>
        <strong>↑</strong> Jump | <strong>←→</strong> Move
    </div>
    
    <div id="gameOverScreen">
        <div class="game-over-content">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
            <button id="restartButton">PLAY AGAIN</button>
        </div>
    </div>
    
    <div id="mobileControls">
        <div style="display: flex; flex-direction: column; gap: 20px; align-items: center;">
            <div class="control-btn" id="jumpBtn">↑</div>
            <div class="control-row">
                <div class="control-btn" id="leftBtn">←</div>
                <div class="control-btn" id="rightBtn">→</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r119/three.min.js"></script>
    <script>
        var sceneWidth;
        var sceneHeight;
        var camera;
        var scene;
        var renderer;
        var dom;
        var sun;
        var rollingGroundSphere;
        var heroSphere;
        var rollingSpeed = 0.005;
        var heroRollingSpeed;
        var worldRadius = 26;
        var heroRadius = 0.2;
        var sphericalHelper;
        var pathAngleValues;
        var heroBaseY = 1.8;
        var bounceValue = 0.1;
        var gravity = 0.005;
        var leftLane = -1;
        var rightLane = 1;
        var middleLane = 0;
        var currentLane;
        var clock;
        var jumping;
        var treeReleaseInterval = 0.7;
        var lastTreeReleaseTime = 0;
        var treesInPath;
        var treesPool;
        var particleGeometry;
        var particleCount = 20;
        var explosionPower = 1.06;
        var particles;
        var scoreText;
        var score;
        var hasCollided;
        var animationId;
        var gameStarted = false;

        init();

        function init() {
            createScene();
            setupEventListeners();
            update();
        }

        function createScene() {
            hasCollided = false;
            score = 0;
            treesInPath = [];
            treesPool = [];
            clock = new THREE.Clock();
            clock.start();
            heroRollingSpeed = (rollingSpeed * worldRadius / heroRadius) / 5;
            sphericalHelper = new THREE.Spherical();
            pathAngleValues = [1.52, 1.57, 1.62];
            sceneWidth = window.innerWidth;
            sceneHeight = window.innerHeight;
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xf0fff0, 0.14);
            camera = new THREE.PerspectiveCamera(60, sceneWidth / sceneHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setClearColor(0xfffafa, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setSize(sceneWidth, sceneHeight);
            dom = document.getElementById('TutContainer');
            dom.appendChild(renderer.domElement);
            
            createTreesPool();
            addWorld();
            addHero();
            addLight();
            addExplosion();
            
            camera.position.z = 6.5;
            camera.position.y = 2.5;
            
            scoreText = document.getElementById('scoreText');
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            gameStarted = true;
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown);
            
            // Mobile controls
            document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleJump();
            });
            
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleMove('left');
            });
            
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleMove('right');
            });
            
            document.getElementById('restartButton').addEventListener('click', restartGame);
        }

        function addExplosion() {
            particleGeometry = new THREE.Geometry();
            for (var i = 0; i < particleCount; i++) {
                var vertex = new THREE.Vector3();
                particleGeometry.vertices.push(vertex);
            }
            var pMaterial = new THREE.PointsMaterial({
                color: 0xff6b6b,
                size: 0.2,
                transparent: true,
                opacity: 1
            });
            particles = new THREE.Points(particleGeometry, pMaterial);
            scene.add(particles);
            particles.visible = false;
        }

        function createTreesPool() {
            var maxTreesInPool = 10;
            var newTree;
            for (var i = 0; i < maxTreesInPool; i++) {
                newTree = createTree();
                treesPool.push(newTree);
            }
        }

        function handleKeyDown(keyEvent) {
            if (!gameStarted || hasCollided) return;
            
            if (keyEvent.keyCode === 37) { // left
                handleMove('left');
            } else if (keyEvent.keyCode === 39) { // right
                handleMove('right');
            } else if (keyEvent.keyCode === 38) { // up/jump
                handleJump();
            }
        }

        function handleMove(direction) {
            if (jumping || hasCollided) return;
            
            var validMove = true;
            
            if (direction === 'left') {
                if (currentLane == middleLane) {
                    currentLane = leftLane;
                } else if (currentLane == rightLane) {
                    currentLane = middleLane;
                } else {
                    validMove = false;
                }
            } else if (direction === 'right') {
                if (currentLane == middleLane) {
                    currentLane = rightLane;
                } else if (currentLane == leftLane) {
                    currentLane = middleLane;
                } else {
                    validMove = false;
                }
            }
            
            if (validMove) {
                jumping = true;
                bounceValue = 0.06;
            }
        }

        function handleJump() {
            if (jumping || hasCollided) return;
            bounceValue = 0.1;
            jumping = true;
        }

        function addHero() {
            var sphereGeometry = new THREE.DodecahedronGeometry(heroRadius, 1);
            var sphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xe5f2f2, 
                flatShading: true 
            });
            jumping = false;
            heroSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            heroSphere.receiveShadow = true;
            heroSphere.castShadow = true;
            scene.add(heroSphere);
            heroSphere.position.y = heroBaseY;
            heroSphere.position.z = 4.8;
            currentLane = middleLane;
            heroSphere.position.x = currentLane;
        }

        function addWorld() {
            var sides = 40;
            var tiers = 40;
            var sphereGeometry = new THREE.SphereGeometry(worldRadius, sides, tiers);
            var sphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfffafa, 
                flatShading: true 
            });
            
            var vertexIndex;
            var vertexVector = new THREE.Vector3();
            var nextVertexVector = new THREE.Vector3();
            var firstVertexVector = new THREE.Vector3();
            var offset = new THREE.Vector3();
            var currentTier = 1;
            var lerpValue = 0.5;
            var heightValue;
            var maxHeight = 0.07;
            
            for (var j = 1; j < tiers - 2; j++) {
                currentTier = j;
                for (var i = 0; i < sides; i++) {
                    vertexIndex = (currentTier * sides) + 1;
                    vertexVector = sphereGeometry.vertices[i + vertexIndex].clone();
                    if (j % 2 !== 0) {
                        if (i == 0) {
                            firstVertexVector = vertexVector.clone();
                        }
                        nextVertexVector = sphereGeometry.vertices[i + vertexIndex + 1].clone();
                        if (i == sides - 1) {
                            nextVertexVector = firstVertexVector;
                        }
                        lerpValue = (Math.random() * (0.75 - 0.25)) + 0.25;
                        vertexVector.lerp(nextVertexVector, lerpValue);
                    }
                    heightValue = (Math.random() * maxHeight) - (maxHeight / 2);
                    offset = vertexVector.clone().normalize().multiplyScalar(heightValue);
                    sphereGeometry.vertices[i + vertexIndex] = (vertexVector.add(offset));
                }
            }
            
            rollingGroundSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            rollingGroundSphere.receiveShadow = true;
            rollingGroundSphere.castShadow = false;
            rollingGroundSphere.rotation.z = -Math.PI / 2;
            scene.add(rollingGroundSphere);
            rollingGroundSphere.position.y = -24;
            rollingGroundSphere.position.z = 2;
            addWorldTrees();
        }

        function addLight() {
            var hemisphereLight = new THREE.HemisphereLight(0xfffafa, 0x000000, 0.9);
            scene.add(hemisphereLight);
            sun = new THREE.DirectionalLight(0xcdc1c5, 0.9);
            sun.position.set(12, 6, -7);
            sun.castShadow = true;
            scene.add(sun);
            sun.shadow.mapSize.width = 256;
            sun.shadow.mapSize.height = 256;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 50;
        }

        function addPathTree() {
            var options = [0, 1, 2];
            var lane = Math.floor(Math.random() * 3);
            addTree(true, lane);
            options.splice(lane, 1);
            if (Math.random() > 0.5) {
                lane = Math.floor(Math.random() * 2);
                addTree(true, options[lane]);
            }
        }

        function addWorldTrees() {
            var numTrees = 36;
            var gap = 6.28 / 36;
            for (var i = 0; i < numTrees; i++) {
                addTree(false, i * gap, true);
                addTree(false, i * gap, false);
            }
        }

        function addTree(inPath, row, isLeft) {
            var newTree;
            if (inPath) {
                if (treesPool.length == 0) return;
                newTree = treesPool.pop();
                newTree.visible = true;
                treesInPath.push(newTree);
                sphericalHelper.set(worldRadius - 0.3, pathAngleValues[row], -rollingGroundSphere.rotation.x + 4);
            } else {
                newTree = createTree();
                var forestAreaAngle = 0;
                if (isLeft) {
                    forestAreaAngle = 1.68 + Math.random() * 0.1;
                } else {
                    forestAreaAngle = 1.46 - Math.random() * 0.1;
                }
                sphericalHelper.set(worldRadius - 0.3, forestAreaAngle, row);
            }
            newTree.position.setFromSpherical(sphericalHelper);
            var rollingGroundVector = rollingGroundSphere.position.clone().normalize();
            var treeVector = newTree.position.clone().normalize();
            newTree.quaternion.setFromUnitVectors(treeVector, rollingGroundVector);
            newTree.rotation.x += (Math.random() * (2 * Math.PI / 10)) + -Math.PI / 10;
            
            rollingGroundSphere.add(newTree);
        }

        function createTree() {
            var sides = 8;
            var tiers = 6;
            var scalarMultiplier = (Math.random() * (0.25 - 0.1)) + 0.05;
            var treeGeometry = new THREE.ConeGeometry(0.5, 1, sides, tiers);
            var treeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x33ff33, 
                flatShading: true 
            });
            
            blowUpTree(treeGeometry.vertices, sides, 0, scalarMultiplier);
            tightenTree(treeGeometry.vertices, sides, 1);
            blowUpTree(treeGeometry.vertices, sides, 2, scalarMultiplier * 1.1, true);
            tightenTree(treeGeometry.vertices, sides, 3);
            blowUpTree(treeGeometry.vertices, sides, 4, scalarMultiplier * 1.2);
            tightenTree(treeGeometry.vertices, sides, 5);
            
            var treeTop = new THREE.Mesh(treeGeometry, treeMaterial);
            treeTop.castShadow = true;
            treeTop.receiveShadow = false;
            treeTop.position.y = 0.9;
            treeTop.rotation.y = (Math.random() * (Math.PI));
            
            var treeTrunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5);
            var trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x886633, 
                flatShading: true 
            });
            var treeTrunk = new THREE.Mesh(treeTrunkGeometry, trunkMaterial);
            treeTrunk.position.y = 0.25;
            
            var tree = new THREE.Object3D();
            tree.add(treeTrunk);
            tree.add(treeTop);
            return tree;
        }

        function blowUpTree(vertices, sides, currentTier, scalarMultiplier, odd) {
            var vertexIndex;
            var vertexVector = new THREE.Vector3();
            var midPointVector = vertices[0].clone();
            var offset;
            for (var i = 0; i < sides; i++) {
                vertexIndex = (currentTier * sides) + 1;
                vertexVector = vertices[i + vertexIndex].clone();
                midPointVector.y = vertexVector.y;
                offset = vertexVector.sub(midPointVector);
                if (odd) {
                    if (i % 2 === 0) {
                        offset.normalize().multiplyScalar(scalarMultiplier / 6);
                        vertices[i + vertexIndex].add(offset);
                    } else {
                        offset.normalize().multiplyScalar(scalarMultiplier);
                        vertices[i + vertexIndex].add(offset);
                        vertices[i + vertexIndex].y = vertices[i + vertexIndex + sides].y + 0.05;
                    }
                } else {
                    if (i % 2 !== 0) {
                        offset.normalize().multiplyScalar(scalarMultiplier / 6);
                        vertices[i + vertexIndex].add(offset);
                    } else {
                        offset.normalize().multiplyScalar(scalarMultiplier);
                        vertices[i + vertexIndex].add(offset);
                        vertices[i + vertexIndex].y = vertices[i + vertexIndex + sides].y + 0.05;
                    }
                }
            }
        }

        function tightenTree(vertices, sides, currentTier) {
            var vertexIndex;
            var vertexVector = new THREE.Vector3();
            var midPointVector = vertices[0].clone();
            var offset;
            for (var i = 0; i < sides; i++) {
                vertexIndex = (currentTier * sides) + 1;
                vertexVector = vertices[i + vertexIndex].clone();
                midPointVector.y = vertexVector.y;
                offset = vertexVector.sub(midPointVector);
                offset.normalize().multiplyScalar(0.06);
                vertices[i + vertexIndex].sub(offset);
            }
        }

        function update() {
            if (!hasCollided) {
                rollingGroundSphere.rotation.x += rollingSpeed;
                heroSphere.rotation.x -= heroRollingSpeed;
                
                if (heroSphere.position.y <= heroBaseY) {
                    jumping = false;
                    bounceValue = (Math.random() * 0.04) + 0.005;
                }
                
                heroSphere.position.y += bounceValue;
                heroSphere.position.x = THREE.Math.lerp(heroSphere.position.x, currentLane, 2 * clock.getDelta());
                bounceValue -= gravity;
                
                if (clock.getElapsedTime() > treeReleaseInterval) {
                    clock.start();
                    addPathTree();
                    if (!hasCollided) {
                        score += Math.floor(2 * treeReleaseInterval);
                        scoreText.innerHTML = score.toString();
                    }
                }
                
                doTreeLogic();
            }
            
            doExplosionLogic();
            render();
            animationId = requestAnimationFrame(update);
        }

        function doTreeLogic() {
            var oneTree;
            var treePos = new THREE.Vector3();
            var treesToRemove = [];
            
            treesInPath.forEach(function(element, index) {
                oneTree = treesInPath[index];
                treePos.setFromMatrixPosition(oneTree.matrixWorld);
                if (treePos.z > 6 && oneTree.visible) {
                    treesToRemove.push(oneTree);
                } else {
                    if (treePos.distanceTo(heroSphere.position) <= 0.6) {
                        if (!hasCollided) {
                            hasCollided = true;
                            explode();
                            gameOver();
                        }
                    }
                }
            });
            
            var fromWhere;
            treesToRemove.forEach(function(element, index) {
                oneTree = treesToRemove[index];
                fromWhere = treesInPath.indexOf(oneTree);
                treesInPath.splice(fromWhere, 1);
                treesPool.push(oneTree);
                oneTree.visible = false;
            });
        }

        function doExplosionLogic() {
            if (!particles.visible) return;
            
            for (var i = 0; i < particleCount; i++) {
                particleGeometry.vertices[i].multiplyScalar(explosionPower);
            }
            
            if (explosionPower > 1.005) {
                explosionPower -= 0.001;
            } else {
                particles.visible = false;
            }
            
            particleGeometry.verticesNeedUpdate = true;
        }

        function explode() {
            particles.position.y = 2;
            particles.position.z = 4.8;
            particles.position.x = heroSphere.position.x;
            
            for (var i = 0; i < particleCount; i++) {
                var vertex = new THREE.Vector3();
                vertex.x = -0.2 + Math.random() * 0.4;
                vertex.y = -0.2 + Math.random() * 0.4;
                vertex.z = -0.2 + Math.random() * 0.4;
                particleGeometry.vertices[i] = vertex;
            }
            
            explosionPower = 1.07;
            particles.visible = true;
        }

        function render() {
            renderer.render(scene, camera);
        }

        function gameOver() {
            document.getElementById('finalScore').innerText = score;
            document.getElementById('gameOverScreen').classList.add('show');
        }

        function restartGame() {
            // Hide game over screen
            document.getElementById('gameOverScreen').classList.remove('show');
            
            // Clean up old scene
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Remove old renderer
            if (renderer && dom) {
                dom.removeChild(renderer.domElement);
            }
            
            // Clear trees
            treesInPath.forEach(tree => {
                rollingGroundSphere.remove(tree);
            });
            treesPool.forEach(tree => {
                if (tree.parent) {
                    tree.parent.remove(tree);
                }
            });
            
            // Reset and recreate
            createScene();
            update();
        }

        function onWindowResize() {
            sceneHeight = window.innerHeight;
            sceneWidth = window.innerWidth;
            renderer.setSize(sceneWidth, sceneHeight);
            camera.aspect = sceneWidth / sceneHeight;
            camera.updateProjectionMatrix();
        }
    </script>
</body>
</html>